# Optimal Tracing and Replay for Debugging Message-Passing Parallel Program

[R. H. B. Netzer and B. P. Miller, "Optimal tracing and replay for debugging message-passing parallel programs," Journal of Supercomputing, vol. 8, pp. 371â€“388, 1995. doi: 10.1007/BF01901615.](https://link.springer.com/article/10.1007/BF01901615)

## Summary

The paper presents a method for efficiently recording and replaying the execution of message-passing parallel programs. Debugging parallel programs is notoriously difficult due to their non-deterministic execution, meaning that different runs of the same program can produce different behaviors due to variations in the order of message receptions. Traditional debugging techniques either introduce excessive overhead by logging too much information or fail to ensure reproducibility, making it difficult to diagnose bugs. This paper proposes an optimal tracing mechanism that records the minimal amount of information necessary to replay an execution deterministically, significantly reducing the size of the trace while maintaining correctness.

A key insight of the paper is that not all message events need to be logged. In naive tracing approaches, every message reception is recorded, leading to large trace sizes and high overhead. Instead, they introduce a technique that only logs the necessary causal dependencies between messages, ensuring that the same ordering constraints are respected during replay while discarding redundant information.

To achieve this, the tracing algorithm relies on causal dependency tracking, using vector clocks to track message orders. This allows the system to determine which message receptions are causally dependent on previous messages and must be enforced during replay. Messages that are not part of a dependency chain do not need to be explicitly logged because they can be recomputed based on existing causal relationships. By logging only these critical dependencies, the approach avoids recording every message exchange, resulting in minimal trace size while still ensuring a correct replay.

Once the trace is recorded, the replay mechanism reconstructs the original execution deterministically. During replay, the program follows the recorded trace and enforces the same causal message ordering as in the original execution. The algorithm ensures that processes only receive messages in the recorded order, preventing variations due to non-deterministic scheduling. The replay only ensures determinism for send messages. It does not deterministically replays the interlacing of all concurrency primitives.